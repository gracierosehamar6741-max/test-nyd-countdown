<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>New Year Countdown (UTC +14 to -10)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      color: white;
      font-family: Arial, Helvetica, sans-serif;
    }

    .container {
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 24px;
    }

    h1 {
      font-size: 42px;
      margin: 0 0 12px;
      letter-spacing: 2px;
    }

    .label {
      font-size: 18px;
      opacity: 0.75;
      margin-bottom: 18px;
      line-height: 1.4;
    }

    .offset {
      font-size: 22px;
      opacity: 0.9;
      margin-bottom: 18px;
    }

    .countdown {
      font-size: 88px;
      font-weight: 800;
      letter-spacing: 4px;
      font-variant-numeric: tabular-nums;
    }

    .small {
      margin-top: 18px;
      font-size: 14px;
      opacity: 0.6;
      max-width: 900px;
    }

    .year {
      font-weight: 700;
      opacity: 0.95;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>New Year’s Countdown</h1>
    <div class="label">
      Always showing the <span class="year" id="targetYear">next</span> New Year that happens <b>somewhere</b><br/>
      (UTC offsets +14 through −10)
    </div>

    <div class="offset" id="offset">UTC …</div>
    <div class="countdown" id="timer">--:--:--</div>

    <div class="small" id="debugLine"></div>
  </div>

  <script>
    // Offsets from +14 down to -10
    const OFFSETS = [];
    for (let o = 14; o >= -10; o--) OFFSETS.push(o);

    function labelOffset(offset) {
      if (offset > 0) return `UTC +${offset}`;
      if (offset < 0) return `UTC ${offset}`; // already includes minus sign
      return `UTC ±0`;
    }

    // Get the "local" date/time components in a given UTC offset,
    // by shifting UTC time by offset hours.
    function getLocalDatePartsInOffset(nowUtcMs, offsetHours) {
      const localMs = nowUtcMs + offsetHours * 3600000;
      const d = new Date(localMs);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth(),     // 0-11
        day: d.getUTCDate(),        // 1-31
        hour: d.getUTCHours(),
        min: d.getUTCMinutes(),
        sec: d.getUTCSeconds()
      };
    }

    // Compute milliseconds (UTC) for Jan 1 00:00 in the *next applicable year* for an offset.
    function getNextNewYearUtcMsForOffset(nowUtcMs, offsetHours) {
      const parts = getLocalDatePartsInOffset(nowUtcMs, offsetHours);

      // In that offset, "New Year" target is Jan 1 00:00.
      // If current local date/time is already Jan 1 00:00 or later of the current year,
      // then target is next year; otherwise target is upcoming Jan 1 of next year anyway
      // BUT careful: if we're in the middle of the year, upcoming New Year is Jan 1 of (year+1).
      //
      // So the target local year is always (current local year + 1),
      // because New Year is next Jan 1.
      const targetLocalYear = parts.year + 1;

      // targetLocal = Jan 1, 00:00:00 in that offset
      // Convert to UTC by subtracting offset.
      const targetUtcMs = Date.UTC(targetLocalYear, 0, 1, 0, 0, 0) - offsetHours * 3600000;

      return { targetUtcMs, targetLocalYear };
    }

    function formatHMS(ms) {
      ms = Math.max(0, ms);
      const total = Math.floor(ms / 1000);
      const h = String(Math.floor(total / 3600)).padStart(2, "0");
      const m = String(Math.floor((total % 3600) / 60)).padStart(2, "0");
      const s = String(total % 60).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function formatDHMS(ms) {
      ms = Math.max(0, ms);
      const total = Math.floor(ms / 1000);
      const days = Math.floor(total / 86400);
      const rem = total % 86400;
      const h = String(Math.floor(rem / 3600)).padStart(2, "0");
      const m = String(Math.floor((rem % 3600) / 60)).padStart(2, "0");
      const s = String(rem % 60).padStart(2, "0");
      return `${days}d ${h}:${m}:${s}`;
    }

    function tick() {
      const now = Date.now();
      let best = null;

      for (const offset of OFFSETS) {
        const { targetUtcMs, targetLocalYear } = getNextNewYearUtcMsForOffset(now, offset);
        const diff = targetUtcMs - now;

        if (best === null || diff < best.diff) {
          best = { offset, diff, targetUtcMs, targetLocalYear };
        }
      }

      document.getElementById("offset").textContent =
        `${labelOffset(best.offset)} hits New Year ${best.targetLocalYear} next`;

      // Big display: days + time
      document.getElementById("timer").textContent = formatDHMS(best.diff);

      // Helpful line so you can sanity-check it
      const localNowParts = getLocalDatePartsInOffset(now, best.offset);
      const targetUtcIso = new Date(best.targetUtcMs).toISOString();
      document.getElementById("targetYear").textContent = best.targetLocalYear;
      document.getElementById("debugLine").textContent =
        `Local time in ${labelOffset(best.offset)} right now: `
        + `${localNowParts.year}-${String(localNowParts.month+1).padStart(2,"0")}-${String(localNowParts.day).padStart(2,"0")} `
        + `${String(localNowParts.hour).padStart(2,"0")}:${String(localNowParts.min).padStart(2,"0")}:${String(localNowParts.sec).padStart(2,"0")} `
        + `• Target (UTC): ${targetUtcIso}`;
    }

    tick();
    setInterval(tick, 1000);
  </script>
</body>
</html>
